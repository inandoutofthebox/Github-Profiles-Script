#!/bin/bash

# Git-Profil-Manager für WSL2 mit SSH-Key-Integration
# Ermöglicht das automatische Wechseln zwischen verschiedenen Git-Profilen

# Farbdefinitionen
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
RED='\033[0;31m'
NC='\033[0m'

# Konfigurationsdatei
CONFIG_FILE="$HOME/.git_profiles.json"
CURRENT_PROFILE=""
return_key_path=""

# Debug-Modus (für Fehlerbehebung)
DEBUG=false

# Verbesserte Debug-Funktion
function debug() {
    if [ "$DEBUG" = true ]; then
        # Auf stderr ausgeben, damit es nicht mit anderen Ausgaben vermischt wird
        echo -e "${YELLOW}DEBUG: $1${NC}" >&2
    fi
}

# Prüfen, ob jq installiert ist
if ! command -v jq &> /dev/null; then
    echo -e "${YELLOW}jq wird benötigt. Installation läuft...${NC}"
    sudo apt update && sudo apt install -y jq
fi

# Profildatei initialisieren
if [ ! -f "$CONFIG_FILE" ]; then
    echo "{}" > "$CONFIG_FILE"
fi

# Funktion zum Laden der Profile
function load_profiles() {
    if [ -f "$CONFIG_FILE" ]; then
        cat "$CONFIG_FILE"
    else
        echo "{}"
    fi
}

# Funktion zum Speichern der Profile
function save_profiles() {
    echo "$1" > "$CONFIG_FILE"
}

# SSH-Key-Verwaltung
function manage_ssh_keys() {
    local profile_name="$1"
    local email="$2"
    local ssh_key_path=""

    # SSH-Verzeichnis prüfen
    if [ ! -d "$HOME/.ssh" ]; then
        mkdir -p "$HOME/.ssh"
        chmod 700 "$HOME/.ssh"
    fi

    # Prüfen, ob SSH-Keys existieren
    if [ -f "$HOME/.ssh/id_ed25519" ] || [ -f "$HOME/.ssh/id_rsa" ]; then
        echo -e "${GREEN}Existierende SSH-Keys gefunden:${NC}"
        ls -la $HOME/.ssh/id_*

        read -p "Möchtest du einen neuen SSH-Key für dieses Profil erstellen? (j/n): " create_new_key

        if [[ "$create_new_key" =~ ^[Jj]$ ]]; then
            create_ssh_key "$profile_name" "$email"
        else
            echo -e "${BLUE}Welchen existierenden SSH-Key möchtest du für dieses Profil verwenden?${NC}"
            select key_file in $(ls $HOME/.ssh/id_* | grep -v '.pub$'); do
                if [ -n "$key_file" ]; then
                    ssh_key_path="$key_file"
                    break
                fi
            done
        fi
    else
        echo -e "${YELLOW}Keine SSH-Keys gefunden.${NC}"
        read -p "Möchtest du einen SSH-Key für dieses Profil erstellen? (j/n): " create_key

        if [[ "$create_key" =~ ^[Jj]$ ]]; then
            create_ssh_key "$profile_name" "$email"
        else
            echo -e "${RED}Kein SSH-Key erstellt. Das Profil wird ohne SSH-Key erstellt.${NC}"
            return
        fi
    fi

    return_key_path="$ssh_key_path"
}

# SSH-Key erstellen
function create_ssh_key() {
    local profile_name="$1"
    local email="$2"
    local key_path=""

    echo -e "${BLUE}Welchen Key-Typ möchtest du generieren?${NC}"
    echo "1) ED25519 (empfohlen, moderner Algorithmus)"
    echo "2) RSA (kompatibel mit älteren Systemen)"
    read -p "Wähle [1-2]: " key_choice

    local key_filename="id_${profile_name,,}"

    if [ "$key_choice" == "2" ]; then
        key_path="$HOME/.ssh/${key_filename}_rsa"
        ssh-keygen -t rsa -b 4096 -C "$email" -f "$key_path"
    else
        key_path="$HOME/.ssh/${key_filename}_ed25519"
        ssh-keygen -t ed25519 -C "$email" -f "$key_path"
    fi

    chmod 600 "$key_path"
    chmod 644 "${key_path}.pub"

    eval "$(ssh-agent -s)" > /dev/null
    ssh-add "$key_path"

    echo -e "${GREEN}SSH-Key wurde erfolgreich erstellt und zum SSH-Agent hinzugefügt.${NC}"
    echo -e "${YELLOW}Öffentlicher Schlüssel (zum Hinzufügen zu GitHub/GitLab):${NC}"
    cat "${key_path}.pub"

    return_key_path="$key_path"
}

# Profil erstellen
function create_profile() {
    local name="$1"
    local email="$2"
    local github_user="$3"
    local directory="${4:-}"
    local ssh_key_path=""

    # SSH-Key-Management
    manage_ssh_keys "$name" "$email"
    ssh_key_path="$return_key_path"

    # Profil laden und erstellen
    local profiles=$(load_profiles)

    # Neues Profil erstellen mit korrekter Initialisierung des directories-Arrays
    if [ -n "$ssh_key_path" ]; then
        if [ -n "$directory" ]; then
            local new_profile=$(echo "$profiles" | jq --arg name "$name" --arg email "$email" --arg github "$github_user" --arg dir "$directory" --arg ssh "$ssh_key_path" \
                '.[$name] = {"user.name": $name, "user.email": $email, "github.user": $github, "ssh.key": $ssh, "directories": [$dir]}')
        else
            local new_profile=$(echo "$profiles" | jq --arg name "$name" --arg email "$email" --arg github "$github_user" --arg ssh "$ssh_key_path" \
                '.[$name] = {"user.name": $name, "user.email": $email, "github.user": $github, "ssh.key": $ssh, "directories": []}')
        fi
    else
        if [ -n "$directory" ]; then
            local new_profile=$(echo "$profiles" | jq --arg name "$name" --arg email "$email" --arg github "$github_user" --arg dir "$directory" \
                '.[$name] = {"user.name": $name, "user.email": $email, "github.user": $github, "directories": [$dir]}')
        else
            local new_profile=$(echo "$profiles" | jq --arg name "$name" --arg email "$email" --arg github "$github_user" \
                '.[$name] = {"user.name": $name, "user.email": $email, "github.user": $github, "directories": []}')
        fi
    fi

    # Profil speichern
    save_profiles "$new_profile"

    echo -e "${GREEN}Profil '$name' wurde erstellt.${NC}"
    if [ -n "$directory" ]; then
        echo -e "${GREEN}Verzeichnis '$directory' dem Profil '$name' zugewiesen.${NC}"
    fi

    # Zum neuen Profil wechseln
    switch_profile "$name"
    
    # Prüfe, ob .bashrc-Integration bereits eingerichtet ist
    check_bashrc_integration
}

# Verzeichnis zu Profil hinzufügen
function add_directory() {
    local name="$1"
    local directory="$2"

    # Absoluter Pfad
    directory=$(realpath "$directory")

    # Profil laden
    local profiles=$(load_profiles)

    # Prüfen, ob Profil existiert
    if ! echo "$profiles" | jq -e --arg name "$name" '.[$name]' > /dev/null; then
        echo -e "${RED}Fehler: Profil '$name' nicht gefunden.${NC}"
        return 1
    fi

    # Verzeichnis zum Profil hinzufügen
    local updated_profile=""

    if echo "$profiles" | jq -e --arg name "$name" '.[$name] | has("directories")' > /dev/null; then
        if echo "$profiles" | jq -e --arg name "$name" '.[$name].directories | type == "array"' > /dev/null; then
            updated_profile=$(echo "$profiles" | jq --arg name "$name" --arg dir "$directory" \
                '.[$name].directories += [$dir]')
        else
            updated_profile=$(echo "$profiles" | jq --arg name "$name" --arg dir "$directory" \
                '.[$name].directories = [$dir]')
        fi
    else
        updated_profile=$(echo "$profiles" | jq --arg name "$name" --arg dir "$directory" \
            '.[$name].directories = [$dir]')
    fi

    # Profil speichern
    save_profiles "$updated_profile"

    echo -e "${GREEN}Verzeichnis '$directory' dem Profil '$name' hinzugefügt.${NC}"
}

# Profil wechseln
function switch_profile() {
    local name="$1"
    local silent="${2:-false}"

    # Profil laden
    local profiles=$(load_profiles)

    # Prüfen, ob Profil existiert
    if ! echo "$profiles" | jq -e --arg name "$name" '.[$name]' > /dev/null; then
        if [ "$silent" != "true" ]; then
            echo -e "${RED}Fehler: Profil '$name' nicht gefunden.${NC}"
        fi
        return 1
    fi

    # Git-Konfigurationen anwenden
    local user_name=$(echo "$profiles" | jq -r --arg name "$name" '.[$name]["user.name"]')
    local user_email=$(echo "$profiles" | jq -r --arg name "$name" '.[$name]["user.email"]')
    local github_user=$(echo "$profiles" | jq -r --arg name "$name" '.[$name]["github.user"]')
    local ssh_key=$(echo "$profiles" | jq -r --arg name "$name" '.[$name]["ssh.key"] // ""')

    # Git-Konfiguration lokal setzen (im aktuellen Verzeichnis), nicht global
    if [ -d ".git" ] || git rev-parse --git-dir > /dev/null 2>&1; then
        # Lokale Git-Konfiguration (im aktuellen Repository)
        git config user.name "$user_name"
        git config user.email "$user_email"
        git config github.user "$github_user"

        # SSH-Key-Konfiguration
        if [ -n "$ssh_key" ] && [ "$ssh_key" != "null" ]; then
            git config core.sshCommand "ssh -i $ssh_key"
        fi

        debug "Lokale Git-Konfiguration für Profil '$name' gesetzt"
    else
        # Globale Git-Konfiguration
        git config --global user.name "$user_name"
        git config --global user.email "$user_email"
        git config --global github.user "$github_user"

        # SSH-Key-Konfiguration
        if [ -n "$ssh_key" ] && [ "$ssh_key" != "null" ]; then
            git config --global core.sshCommand "ssh -i $ssh_key"
        fi

        debug "Globale Git-Konfiguration für Profil '$name' gesetzt"
    fi

    # Aktuelles Profil setzen
    CURRENT_PROFILE="$name"

    if [ "$silent" != "true" ]; then
        echo -e "${GREEN}Zu Profil '$name' gewechselt.${NC}"
        echo -e "${BLUE}Name: ${NC}$user_name"
        echo -e "${BLUE}E-Mail: ${NC}$user_email"
        echo -e "${BLUE}GitHub-Benutzer: ${NC}$github_user"
        if [ -n "$ssh_key" ] && [ "$ssh_key" != "null" ]; then
            echo -e "${BLUE}SSH-Key: ${NC}$ssh_key"
        fi
    fi

    return 0
}

# Passendes Profil für ein Verzeichnis finden
function find_profile_for_directory() {
    local directory=$(realpath "$1")
    local profiles=$(load_profiles)
    local best_match=""
    local best_match_length=0

    debug "Suche Profil für Verzeichnis: $directory"

    # Alle Profile durchlaufen
    for profile in $(echo "$profiles" | jq -r 'keys[]'); do
        debug "Prüfe Profil: $profile"

        # Sicherer Zugriff auf directories-Feld
        if echo "$profiles" | jq -e --arg profile "$profile" '.[$profile] | has("directories")' > /dev/null; then
            if echo "$profiles" | jq -e --arg profile "$profile" '.[$profile].directories | type == "array"' > /dev/null; then
                # Verzeichnisse des Profils durchlaufen
                for dir in $(echo "$profiles" | jq -r --arg profile "$profile" '.[$profile].directories[]'); do
                    if [ -n "$dir" ] && [[ "$directory/" == "$dir/"* ]]; then
                        # Länge des übereinstimmenden Pfads berechnen
                        local match_length=${#dir}
                        debug "✓ Übereinstimmung gefunden: $directory ist in $dir (Länge: $match_length)"

                        # Beste Übereinstimmung finden (längster übereinstimmender Pfad)
                        if [ $match_length -gt $best_match_length ]; then
                            best_match="$profile"
                            best_match_length=$match_length
                            debug "Neue beste Übereinstimmung: $best_match (Länge: $best_match_length)"
                        fi
                    else
                        debug "✗ Keine Übereinstimmung: $directory ist nicht in $dir"
                    fi
                done
            fi
        fi
    done

    debug "Finale beste Übereinstimmung: $best_match"
    echo "$best_match"

    # Rückgabe: Erfolg, wenn ein Profil gefunden wurde
    if [ -n "$best_match" ]; then
        return 0
    else
        return 1
    fi
}

# Automatisch Profil wechseln
function auto_switch_profile() {
    local current_dir=$(pwd)

    # Prüfen, ob wir in einem Git-Repository sind
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        debug "Kein Git-Repository im aktuellen Verzeichnis gefunden"
        echo -e "${YELLOW}Kein Git-Repository im aktuellen Verzeichnis gefunden.${NC}"
        return 1
    fi

    local profile=$(find_profile_for_directory "$current_dir")
    debug "Gefundenes Profil: $profile"

    if [ -n "$profile" ]; then
        if [ "$profile" != "$CURRENT_PROFILE" ]; then
            switch_profile "$profile" "false"  # Silent: false, um Feedback zu geben
            echo -e "${GREEN}Automatisch zu Profil '$profile' für Verzeichnis '$current_dir' gewechselt.${NC}"
        else
            echo -e "${BLUE}Profil '$profile' ist bereits aktiv.${NC}"
        fi
        return 0
    else
        echo -e "${YELLOW}Kein passendes Profil für Verzeichnis '$current_dir' gefunden.${NC}"
        return 1
    fi
}

# Profile auflisten
function list_profiles() {
    local profiles=$(load_profiles)

    # Prüfen, ob Profile existieren
    local profile_count=$(echo "$profiles" | jq 'keys | length')
    if [ -z "$profile_count" ] || [ "$profile_count" -eq 0 ]; then
        echo -e "${YELLOW}Keine Profile vorhanden.${NC}"
        return
    fi

    echo -e "${BLUE}Verfügbare Profile:${NC}"
    for profile in $(echo "$profiles" | jq -r 'keys[]'); do
        echo ""
        echo -e "  ${GREEN}$profile:${NC}"

        # Werte mit Standardwerten
        local name=$(echo "$profiles" | jq -r --arg p "$profile" '.[$p]["user.name"] // "Nicht angegeben"')
        local email=$(echo "$profiles" | jq -r --arg p "$profile" '.[$p]["user.email"] // "Nicht angegeben"')
        local github=$(echo "$profiles" | jq -r --arg p "$profile" '.[$p]["github.user"] // "Nicht angegeben"')

        echo -e "    ${BLUE}Name:${NC} $name"
        echo -e "    ${BLUE}E-Mail:${NC} $email"
        echo -e "    ${BLUE}GitHub-Benutzer:${NC} $github"

        # SSH-Key anzeigen
        local ssh_key=$(echo "$profiles" | jq -r --arg p "$profile" '.[$p]["ssh.key"] // ""')
        if [ -n "$ssh_key" ] && [ "$ssh_key" != "null" ]; then
            echo -e "    ${BLUE}SSH-Key:${NC} $ssh_key"
        fi

        echo -e "    ${BLUE}Verzeichnisse:${NC}"

        # Verzeichnisse anzeigen
        if echo "$profiles" | jq -e --arg p "$profile" '.[$p] | has("directories")' > /dev/null; then
            if echo "$profiles" | jq -e --arg p "$profile" '.[$p].directories | type == "array"' > /dev/null; then
                local dir_count=$(echo "$profiles" | jq --arg p "$profile" '.[$p].directories | length')
                if [ "$dir_count" -gt 0 ]; then
                    for dir in $(echo "$profiles" | jq -r --arg p "$profile" '.[$p].directories[]'); do
                        if [ -n "$dir" ] && [ "$dir" != "null" ]; then
                            echo -e "      - $dir"
                        fi
                    done
                else
                    echo -e "      ${YELLOW}Keine Verzeichnisse definiert.${NC}"
                fi
            else
                echo -e "      ${YELLOW}Keine Verzeichnisse definiert.${NC}"
            fi
        else
            echo -e "      ${YELLOW}Keine Verzeichnisse definiert.${NC}"
        fi
    done
}

# Funktion zur Selbstinstallation des Skripts
function setup_self_installation() {
    echo -e "${BLUE}Starte Selbstinstallation des Git-Profil-Managers...${NC}"
    
    # 1. Kopiere das Skript nach /usr/local/bin/git-profile
    local script_path=$(realpath "$0")
    local target_path="/usr/local/bin/git-profile"
    
    if [ "$script_path" != "$target_path" ]; then
        echo -e "${YELLOW}Kopiere Skript nach $target_path...${NC}"
        sudo cp "$script_path" "$target_path"
        sudo chmod +x "$target_path"
        echo -e "${GREEN}Skript wurde nach $target_path kopiert und ausführbar gemacht.${NC}"
    else
        echo -e "${GREEN}Skript befindet sich bereits im Zielpfad.${NC}"
    fi
    
    # Prüfe die .bashrc-Integration und füge sie hinzu, falls nötig
    check_bashrc_integration
    
    echo -e "${GREEN}Installation abgeschlossen! Git-Profil-Manager ist jetzt einsatzbereit.${NC}"
}

# .bashrc-Integration prüfen und einfügen
function check_bashrc_integration() {
    local bashrc_file="$HOME/.bashrc"
    local integration_marker="# Git-Profil automatisch wechseln"
    
    # Prüfen, ob die Integration bereits in der .bashrc vorhanden ist
    if grep -q "$integration_marker" "$bashrc_file"; then
        echo -e "${GREEN}Die Git-Profil-Manager-Integration ist bereits in deiner .bashrc eingerichtet.${NC}"
    else
        echo -e "${YELLOW}Die Git-Profil-Manager-Integration ist noch nicht in deiner .bashrc eingerichtet.${NC}"
        read -p "Möchtest du die automatische Profilumschaltung in deine .bashrc einfügen? (j/n): " add_integration
        
        if [[ "$add_integration" =~ ^[Jj]$ ]]; then
            # Einrichtung zur .bashrc hinzufügen
            cat >> "$bashrc_file" << EOL

$integration_marker
cd() {
    builtin cd "\$@"
    if git rev-parse --git-dir > /dev/null 2>&1; then
        git-profile auto > /dev/null
    fi
}

# Initial beim Start der Shell ausführen
if git rev-parse --git-dir > /dev/null 2>&1; then
    git-profile auto > /dev/null
fi
EOL
            echo -e "${GREEN}Die Git-Profil-Manager-Integration wurde zu deiner .bashrc hinzugefügt.${NC}"
            echo -e "${BLUE}Führe 'source ~/.bashrc' aus, um die Änderungen zu aktivieren.${NC}"
            
            # Automatisch source ~/.bashrc ausführen
            echo -e "${YELLOW}Lade .bashrc neu...${NC}"
            source "$bashrc_file"
            echo -e "${GREEN}.bashrc wurde neu geladen.${NC}"
        else
            echo -e "${YELLOW}Integration nicht hinzugefügt. Du kannst 'git-profile auto' manuell aufrufen.${NC}"
        fi
    fi
}

# Hilfe anzeigen
function show_help() {
    echo -e "${BLUE}Git-Profil-Manager für WSL2${NC}"
    echo ""
    echo -e "Verwendung:"
    echo -e "  $0 ${GREEN}create${NC} <name> <email> <github-user> [verzeichnis]  - Erstellt ein neues Profil"
    echo -e "  $0 ${GREEN}add-dir${NC} <name> <verzeichnis>                      - Fügt ein Verzeichnis zu einem Profil hinzu"
    echo -e "  $0 ${GREEN}switch${NC} <name>                                     - Wechselt zu einem Profil"
    echo -e "  $0 ${GREEN}auto${NC}                                              - Wechselt automatisch basierend auf dem aktuellen Verzeichnis"
    echo -e "  $0 ${GREEN}auto debug${NC}                                        - Zeigt Debug-Informationen während des Profilwechsels"
    echo -e "  $0 ${GREEN}list${NC}                                              - Listet alle Profile auf"
    echo -e "  $0 ${GREEN}install${NC}                                           - Installiert das Skript in /usr/local/bin und richtet .bashrc ein"
    echo -e "  $0 ${GREEN}help${NC}                                              - Zeigt diese Hilfe an"
    echo ""
    echo -e "Beispiele:"
    echo -e "  $0 create \"Arbeit\" \"max@firma.com\" \"MaxFirma\" \"/pfad/zu/projekten/arbeit/\""
    echo -e "  $0 add-dir \"Arbeit\" \"/pfad/zu/weiteren/arbeitsprojekten/\""
    echo -e "  $0 install"
}

# Hauptfunktion
case "$1" in
    create)
        if [ $# -lt 4 ]; then
            echo -e "${RED}Fehler: Zu wenige Argumente.${NC}"
            echo -e "Verwendung: $0 create <name> <email> <github-user> [verzeichnis]"
            exit 1
        fi
        create_profile "$2" "$3" "$4" "${5:-}"
        ;;
    add-dir)
        if [ $# -ne 3 ]; then
            echo -e "${RED}Fehler: Falsche Anzahl an Argumenten.${NC}"
            echo -e "Verwendung: $0 add-dir <name> <verzeichnis>"
            exit 1
        fi
        add_directory "$2" "$3"
        ;;
    switch)
        if [ $# -ne 2 ]; then
            echo -e "${RED}Fehler: Falsche Anzahl an Argumenten.${NC}"
            echo -e "Verwendung: $0 switch <name>"
            exit 1
        fi
        switch_profile "$2"
        ;;
    auto)
        # Debug-Modus für den auto-Befehl aktivieren
        if [ "$2" = "debug" ]; then
            DEBUG=true
            echo -e "${YELLOW}Debug-Modus aktiviert${NC}"
        fi
        auto_switch_profile
        ;;
    list)
        list_profiles
        ;;
    install)
        # Selbstinstallation ausführen
        setup_self_installation
        ;;
    help|*)
        show_help
        ;;
esac

exit 0

