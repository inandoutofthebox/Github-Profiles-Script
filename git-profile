#!/bin/bash

# Git Profile Manager für WSL2 mit SSH Key Integration
# Ermöglicht automatisches Wechseln zwischen verschiedenen Git-Profilen

# Farbdefinitionen
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
RED='\033[0;31m'
CYAN='\033[0;36m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

# Konfigurationsdateien
CONFIG_FILE="$HOME/.git_profiles.json"
LOG_FILE="$HOME/.git_profile_manager.log"
CURRENT_PROFILE=""
return_key_path=""

# Debug-Modus (für Fehlerbehebung)
DEBUG=false

# Version des Scripts
VERSION="2.0.0"

# Erweiterte Info-Funktion
function info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

# Erfolgs-Funktion
function success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# Warnung-Funktion
function warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Fehler-Funktion
function error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Debug-Funktion mit Logging
function debug() {
    if [ "$DEBUG" = true ]; then
        echo -e "${PURPLE}[DEBUG]${NC} $1" >&2
        echo "$(date '+%Y-%m-%d %H:%M:%S') [DEBUG] $1" >> "$LOG_FILE"
    fi
}

# Logging-Funktion
function log_action() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [ACTION] $1" >> "$LOG_FILE"
}

# Banner anzeigen
function show_banner() {
    echo -e "
${CYAN}╔══════════════════════════════════════════════════════╗
║                                                      ║
║           Git Profile Manager v${VERSION}                ║
║              für WSL2 & Linux                        ║
║                                                      ║
╚══════════════════════════════════════════════════════╝${NC}
"
}

# Prüfe ob jq installiert ist
function check_dependencies() {
    info "Prüfe Abhängigkeiten..."

    if ! command -v jq &> /dev/null; then
        warning "jq wird benötigt. Installiere jq..."
        if command -v apt &> /dev/null; then
            sudo apt update && sudo apt install -y jq
        elif command -v yum &> /dev/null; then
            sudo yum install -y jq
        elif command -v brew &> /dev/null; then
            brew install jq
        else
            error "Konnte jq nicht automatisch installieren. Bitte manuell installieren."
            exit 1
        fi
        success "jq wurde erfolgreich installiert."
    else
        debug "jq ist bereits installiert."
    fi

    # Prüfe ob ssh-keygen verfügbar ist
    if ! command -v ssh-keygen &> /dev/null; then
        error "ssh-keygen ist nicht verfügbar. Bitte OpenSSH installieren."
        exit 1
    fi

    success "Alle Abhängigkeiten sind verfügbar."
}

# Initialisiere Profil-Datei
function initialize_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        info "Erstelle Konfigurationsdatei: $CONFIG_FILE"
        echo "{}" > "$CONFIG_FILE"
        chmod 600 "$CONFIG_FILE"  # Sicherheit
        success "Konfigurationsdatei erstellt."
    fi

    # Erstelle Log-Datei falls nicht vorhanden
    if [ ! -f "$LOG_FILE" ]; then
        touch "$LOG_FILE"
        chmod 600 "$LOG_FILE"
    fi
}

# Lade Profile
function load_profiles() {
    if [ -f "$CONFIG_FILE" ]; then
        cat "$CONFIG_FILE"
    else
        echo "{}"
    fi
}

# Speichere Profile
function save_profiles() {
    echo "$1" > "$CONFIG_FILE"
    chmod 600 "$CONFIG_FILE"
    debug "Profile gespeichert in $CONFIG_FILE"
}

# Verbesserte SSH-Key Erstellung
function create_ssh_key() {
    local profile_name="$1"
    local email="$2"
    local key_path=""

    info "Erstelle SSH-Key für Profil '$profile_name'..."

    # SSH-Verzeichnis sicherstellen
    if [ ! -d "$HOME/.ssh" ]; then
        mkdir -p "$HOME/.ssh"
        chmod 700 "$HOME/.ssh"
        debug "SSH-Verzeichnis erstellt: $HOME/.ssh"
    fi

    echo -e "${CYAN}Welchen Key-Typ möchten Sie generieren?${NC}"
    echo "1) ED25519 (empfohlen, moderner Algorithmus)"
    echo "2) RSA 4096 (kompatibel mit älteren Systemen)"
    echo "3) RSA 2048 (für sehr alte Systeme)"

    while true; do
        read -p "Wählen Sie [1-3]: " key_choice
        case $key_choice in
            1)
                key_path="$HOME/.ssh/id_${profile_name,,}_ed25519"
                info "Generiere ED25519 Key..."
                if ssh-keygen -t ed25519 -C "$email" -f "$key_path" -N ""; then
                    success "ED25519 Key erfolgreich erstellt."
                    break
                else
                    error "Fehler beim Erstellen des ED25519 Keys."
                    return 1
                fi
                ;;
            2)
                key_path="$HOME/.ssh/id_${profile_name,,}_rsa4096"
                info "Generiere RSA 4096 Key..."
                if ssh-keygen -t rsa -b 4096 -C "$email" -f "$key_path" -N ""; then
                    success "RSA 4096 Key erfolgreich erstellt."
                    break
                else
                    error "Fehler beim Erstellen des RSA 4096 Keys."
                    return 1
                fi
                ;;
            3)
                key_path="$HOME/.ssh/id_${profile_name,,}_rsa2048"
                info "Generiere RSA 2048 Key..."
                if ssh-keygen -t rsa -b 2048 -C "$email" -f "$key_path" -N ""; then
                    success "RSA 2048 Key erfolgreich erstellt."
                    break
                else
                    error "Fehler beim Erstellen des RSA 2048 Keys."
                    return 1
                fi
                ;;
            *)
                warning "Ungültige Auswahl. Bitte wählen Sie 1, 2 oder 3."
                ;;
        esac
    done

    # Berechtigungen setzen
    chmod 600 "$key_path"
    chmod 644 "${key_path}.pub"

    # Key zum SSH-Agent hinzufügen
    info "Füge Key zum SSH-Agent hinzu..."
    if eval "$(ssh-agent -s)" > /dev/null 2>&1; then
        if ssh-add "$key_path" 2>/dev/null; then
            success "SSH-Key wurde erfolgreich zum SSH-Agent hinzugefügt."
        else
            warning "Konnte SSH-Key nicht zum SSH-Agent hinzufügen. Das ist normal, wenn kein SSH-Agent läuft."
        fi
    fi

    # Öffentlichen Key anzeigen
    echo -e "\n${CYAN}╔══════════════════════════════════════════════════════╗"
    echo -e "║                    PUBLIC KEY                        ║"
    echo -e "║      (Fügen Sie diesen zu GitHub/GitLab hinzu)       ║"
    echo -e "╚══════════════════════════════════════════════════════╝${NC}"
    echo ""
    cat "${key_path}.pub"
    echo ""
    echo -e "${YELLOW}Tipp: Der öffentliche Key wurde in die Zwischenablage kopiert (falls xclip installiert ist).${NC}"

    # Versuche den Key in die Zwischenablage zu kopieren
    if command -v xclip &> /dev/null; then
        cat "${key_path}.pub" | xclip -selection clipboard
        success "Öffentlicher Key in Zwischenablage kopiert."
    elif command -v pbcopy &> /dev/null; then
        cat "${key_path}.pub" | pbcopy
        success "Öffentlicher Key in Zwischenablage kopiert."
    fi

    return_key_path="$key_path"
    log_action "SSH-Key erstellt für Profil '$profile_name': $key_path"
    return 0
}

# Verbesserte SSH-Key Verwaltung
function manage_ssh_keys() {
    local profile_name="$1"
    local email="$2"
    local ssh_key_path=""

    info "SSH-Key Verwaltung für Profil '$profile_name'..."

    # SSH-Verzeichnis prüfen
    if [ ! -d "$HOME/.ssh" ]; then
        mkdir -p "$HOME/.ssh"
        chmod 700 "$HOME/.ssh"
        info "SSH-Verzeichnis erstellt."
    fi

    # Existierende SSH-Keys finden
    local existing_keys=($(find "$HOME/.ssh" -name "id_*" -not -name "*.pub" 2>/dev/null))

    if [ ${#existing_keys[@]} -gt 0 ]; then
        success "Existierende SSH-Keys gefunden:"
        for i in "${!existing_keys[@]}"; do
            echo "  $((i+1))) ${existing_keys[i]}"
        done
        echo "  $((${#existing_keys[@]}+1))) Neuen SSH-Key erstellen"
        echo "  $((${#existing_keys[@]}+2))) Kein SSH-Key verwenden"

        while true; do
            read -p "Wählen Sie eine Option [1-$((${#existing_keys[@]}+2))]: " choice
            if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le $((${#existing_keys[@]}+2)) ]; then
                if [ "$choice" -eq $((${#existing_keys[@]}+1)) ]; then
                    # Neuen Key erstellen
                    if create_ssh_key "$profile_name" "$email"; then
                        ssh_key_path="$return_key_path"
                    else
                        error "Fehler beim Erstellen des SSH-Keys."
                        return 1
                    fi
                    break
                elif [ "$choice" -eq $((${#existing_keys[@]}+2)) ]; then
                    # Kein SSH-Key
                    warning "Profil wird ohne SSH-Key erstellt."
                    ssh_key_path=""
                    break
                else
                    # Existierenden Key verwenden
                    ssh_key_path="${existing_keys[$((choice-1))]}"
                    success "Verwende existierenden SSH-Key: $ssh_key_path"
                    break
                fi
            else
                warning "Ungültige Auswahl. Bitte versuchen Sie es erneut."
            fi
        done
    else
        warning "Keine SSH-Keys gefunden."
        while true; do
            read -p "Möchten Sie einen SSH-Key für dieses Profil erstellen? (j/n): " create_key
            case $create_key in
                [JjYy]*)
                    if create_ssh_key "$profile_name" "$email"; then
                        ssh_key_path="$return_key_path"
                    else
                        error "Fehler beim Erstellen des SSH-Keys."
                        return 1
                    fi
                    break
                    ;;
                [Nn]*)
                    warning "Profil wird ohne SSH-Key erstellt."
                    ssh_key_path=""
                    break
                    ;;
                *)
                    warning "Bitte antworten Sie mit 'j' für ja oder 'n' für nein."
                    ;;
            esac
        done
    fi

    return_key_path="$ssh_key_path"
    return 0
}

# Erweiterte Profil-Erstellung
function create_profile() {
    local name="$1"
    local email="$2"
    local github_user="$3"
    local directory="${4:-}"
    local ssh_key_path=""

    info "Erstelle Profil '$name'..."
    log_action "Starte Profil-Erstellung: $name"

    # Validierung
    if [ -z "$name" ] || [ -z "$email" ] || [ -z "$github_user" ]; then
        error "Name, E-Mail und GitHub-Benutzer sind erforderlich."
        return 1
    fi

    # E-Mail-Format prüfen
    if [[ ! "$email" =~ ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$ ]]; then
        error "Ungültiges E-Mail-Format: $email"
        return 1
    fi

    # Prüfe ob Profil bereits existiert
    local profiles=$(load_profiles)
    if echo "$profiles" | jq -e --arg name "$name" '.[$name]' > /dev/null 2>&1; then
        error "Profil '$name' existiert bereits."
        return 1
    fi

    # SSH-Key Verwaltung
    if manage_ssh_keys "$name" "$email"; then
        ssh_key_path="$return_key_path"
    else
        error "Fehler bei der SSH-Key Verwaltung."
        return 1
    fi

    # Verzeichnis validieren falls angegeben
    if [ -n "$directory" ]; then
        if [ ! -d "$directory" ]; then
            warning "Verzeichnis '$directory' existiert nicht."
            while true; do
                read -p "Möchten Sie es erstellen? (j/n): " create_dir
                case $create_dir in
                    [JjYy]*)
                        if mkdir -p "$directory"; then
                            success "Verzeichnis '$directory' wurde erstellt."
                        else
                            error "Konnte Verzeichnis '$directory' nicht erstellen."
                            return 1
                        fi
                        break
                        ;;
                    [Nn]*)
                        directory=""
                        break
                        ;;
                    *)
                        warning "Bitte antworten Sie mit 'j' für ja oder 'n' für nein."
                        ;;
                esac
            done
        fi
        # Absoluten Pfad verwenden
        directory=$(realpath "$directory" 2>/dev/null || echo "$directory")
    fi

    # Neues Profil erstellen
    local new_profile
    if [ -n "$ssh_key_path" ]; then
        if [ -n "$directory" ]; then
            new_profile=$(echo "$profiles" | jq --arg name "$name" --arg email "$email" --arg github "$github_user" --arg dir "$directory" --arg ssh "$ssh_key_path" \
                '.[$name] = {"user.name": $name, "user.email": $email, "github.user": $github, "ssh.key": $ssh, "directories": [$dir], "created": now | strftime("%Y-%m-%d %H:%M:%S")}')
        else
            new_profile=$(echo "$profiles" | jq --arg name "$name" --arg email "$email" --arg github "$github_user" --arg ssh "$ssh_key_path" \
                '.[$name] = {"user.name": $name, "user.email": $email, "github.user": $github, "ssh.key": $ssh, "directories": [], "created": now | strftime("%Y-%m-%d %H:%M:%S")}')
        fi
    else
        if [ -n "$directory" ]; then
            new_profile=$(echo "$profiles" | jq --arg name "$name" --arg email "$email" --arg github "$github_user" --arg dir "$directory" \
                '.[$name] = {"user.name": $name, "user.email": $email, "github.user": $github, "directories": [$dir], "created": now | strftime("%Y-%m-%d %H:%M:%S")}')
        else
            new_profile=$(echo "$profiles" | jq --arg name "$name" --arg email "$email" --arg github "$github_user" \
                '.[$name] = {"user.name": $name, "user.email": $email, "github.user": $github, "directories": [], "created": now | strftime("%Y-%m-%d %H:%M:%S")}')
        fi
    fi

    # Profil speichern
    if save_profiles "$new_profile"; then
        success "Profil '$name' wurde erfolgreich erstellt."
        log_action "Profil erstellt: $name"

        if [ -n "$directory" ]; then
            success "Verzeichnis '$directory' wurde dem Profil '$name' zugewiesen."
        fi

        # Zum neuen Profil wechseln
        switch_profile "$name"

        # .bashrc Integration prüfen
        check_bashrc_integration

        return 0
    else
        error "Fehler beim Speichern des Profils."
        return 1
    fi
}

# Verzeichnis zu Profil hinzufügen
function add_directory() {
    local name="$1"
    local directory="$2"

    info "Füge Verzeichnis '$directory' zu Profil '$name' hinzu..."

    # Validierung
    if [ -z "$name" ] || [ -z "$directory" ]; then
        error "Profilname und Verzeichnis sind erforderlich."
        return 1
    fi

    # Prüfe ob Verzeichnis existiert
    if [ ! -d "$directory" ]; then
        error "Verzeichnis '$directory' existiert nicht."
        return 1
    fi

    # Absoluten Pfad verwenden
    directory=$(realpath "$directory")

    # Profile laden
    local profiles=$(load_profiles)

    # Prüfe ob Profil existiert
    if ! echo "$profiles" | jq -e --arg name "$name" '.[$name]' > /dev/null; then
        error "Profil '$name' wurde nicht gefunden."
        return 1
    fi

    # Prüfe ob Verzeichnis bereits zugewiesen ist
    if echo "$profiles" | jq -e --arg name "$name" --arg dir "$directory" '.[$name].directories[]? | select(. == $dir)' > /dev/null 2>&1; then
        warning "Verzeichnis '$directory' ist bereits dem Profil '$name' zugewiesen."
        return 0
    fi

    # Verzeichnis hinzufügen
    local updated_profile
    if echo "$profiles" | jq -e --arg name "$name" '.[$name] | has("directories")' > /dev/null; then
        if echo "$profiles" | jq -e --arg name "$name" '.[$name].directories | type == "array"' > /dev/null; then
            updated_profile=$(echo "$profiles" | jq --arg name "$name" --arg dir "$directory" \
                '.[$name].directories += [$dir] | .[$name].directories |= unique')
        else
            updated_profile=$(echo "$profiles" | jq --arg name "$name" --arg dir "$directory" \
                '.[$name].directories = [$dir]')
        fi
    else
        updated_profile=$(echo "$profiles" | jq --arg name "$name" --arg dir "$directory" \
            '.[$name].directories = [$dir]')
    fi

    # Profil speichern
    if save_profiles "$updated_profile"; then
        success "Verzeichnis '$directory' wurde zu Profil '$name' hinzugefügt."
        log_action "Verzeichnis hinzugefügt: $directory -> $name"
        return 0
    else
        error "Fehler beim Speichern des Profils."
        return 1
    fi
}

# Verbessertes Profil-Wechseln
function switch_profile() {
    local name="$1"
    local silent="${2:-false}"

    debug "Wechsle zu Profil: $name (silent: $silent)"

    # Profile laden
    local profiles=$(load_profiles)

    # Prüfe ob Profil existiert
    if ! echo "$profiles" | jq -e --arg name "$name" '.[$name]' > /dev/null; then
        if [ "$silent" != "true" ]; then
            error "Profil '$name' wurde nicht gefunden."
        fi
        return 1
    fi

    # Git-Konfigurationen anwenden
    local user_name=$(echo "$profiles" | jq -r --arg name "$name" '.[$name]["user.name"]')
    local user_email=$(echo "$profiles" | jq -r --arg name "$name" '.[$name]["user.email"]')
    local github_user=$(echo "$profiles" | jq -r --arg name "$name" '.[$name]["github.user"]')
    local ssh_key=$(echo "$profiles" | jq -r --arg name "$name" '.[$name]["ssh.key"] // ""')

    # Prüfe ob wir in einem Git-Repository sind
    if [ -d ".git" ] || git rev-parse --git-dir > /dev/null 2>&1; then
        # Lokale Git-Konfiguration (im aktuellen Repository)
        git config user.name "$user_name"
        git config user.email "$user_email"
        git config github.user "$github_user"

        # SSH-Key Konfiguration
        if [ -n "$ssh_key" ] && [ "$ssh_key" != "null" ] && [ -f "$ssh_key" ]; then
            git config core.sshCommand "ssh -i $ssh_key -o IdentitiesOnly=yes"
            debug "SSH-Key konfiguriert für lokales Repository: $ssh_key"
        else
            git config --unset core.sshCommand 2>/dev/null || true
        fi

        debug "Lokale Git-Konfiguration gesetzt für Profil '$name'"
    else
        # Globale Git-Konfiguration
        git config --global user.name "$user_name"
        git config --global user.email "$user_email"
        git config --global github.user "$github_user"

        # SSH-Key Konfiguration
        if [ -n "$ssh_key" ] && [ "$ssh_key" != "null" ] && [ -f "$ssh_key" ]; then
            git config --global core.sshCommand "ssh -i $ssh_key -o IdentitiesOnly=yes"
            debug "SSH-Key konfiguriert global: $ssh_key"
        else
            git config --global --unset core.sshCommand 2>/dev/null || true
        fi

        debug "Globale Git-Konfiguration gesetzt für Profil '$name'"
    fi

    # Aktuelles Profil setzen
    CURRENT_PROFILE="$name"

    if [ "$silent" != "true" ]; then
        success "Zu Profil '$name' gewechselt."
        echo -e "  ${CYAN}Name:${NC} $user_name"
        echo -e "  ${CYAN}E-Mail:${NC} $user_email"
        echo -e "  ${CYAN}GitHub-Benutzer:${NC} $github_user"
        if [ -n "$ssh_key" ] && [ "$ssh_key" != "null" ] && [ -f "$ssh_key" ]; then
            echo -e "  ${CYAN}SSH-Key:${NC} $ssh_key"
        else
            echo -e "  ${CYAN}SSH-Key:${NC} ${YELLOW}Nicht konfiguriert${NC}"
        fi
    fi

    log_action "Profil gewechselt: $name"
    return 0
}

# Passendes Profil für Verzeichnis finden
function find_profile_for_directory() {
    local directory=$(realpath "$1" 2>/dev/null || echo "$1")
    local profiles=$(load_profiles)
    local best_match=""
    local best_match_length=0

    debug "Suche Profil für Verzeichnis: $directory"

    # Durch alle Profile iterieren
    for profile in $(echo "$profiles" | jq -r 'keys[]'); do
        debug "Prüfe Profil: $profile"

        # Sicherer Zugriff auf directories Feld
        if echo "$profiles" | jq -e --arg profile "$profile" '.[$profile] | has("directories")' > /dev/null; then
            if echo "$profiles" | jq -e --arg profile "$profile" '.[$profile].directories | type == "array"' > /dev/null; then
                # Durch Verzeichnisse des Profils iterieren
                for dir in $(echo "$profiles" | jq -r --arg profile "$profile" '.[$profile].directories[]'); do
                    if [ -n "$dir" ] && [[ "$directory/" == "$dir/"* ]]; then
                        # Länge des übereinstimmenden Pfads berechnen
                        local match_length=${#dir}
                        debug "✓ Übereinstimmung gefunden: $directory ist in $dir (Länge: $match_length)"

                        # Beste Übereinstimmung finden (längster übereinstimmender Pfad)
                        if [ $match_length -gt $best_match_length ]; then
                            best_match="$profile"
                            best_match_length=$match_length
                            debug "Neue beste Übereinstimmung: $best_match (Länge: $best_match_length)"
                        fi
                    else
                        debug "✗ Keine Übereinstimmung: $directory ist nicht in $dir"
                    fi
                done
            fi
        fi
    done

    debug "Finale beste Übereinstimmung: $best_match"
    echo "$best_match"

    # Rückgabe: Erfolg wenn ein Profil gefunden wurde
    if [ -n "$best_match" ]; then
        return 0
    else
        return 1
    fi
}

# Automatisches Profil-Wechseln
function auto_switch_profile() {
    local current_dir=$(pwd)

    debug "Auto-Switch in Verzeichnis: $current_dir"

    # Prüfe ob wir in einem Git-Repository sind
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        debug "Kein Git-Repository im aktuellen Verzeichnis gefunden"
        if [ "$DEBUG" = true ]; then
            warning "Kein Git-Repository im aktuellen Verzeichnis gefunden."
        fi
        return 1
    fi

    local profile=$(find_profile_for_directory "$current_dir")
    debug "Gefundenes Profil: $profile"

    if [ -n "$profile" ]; then
        if [ "$profile" != "$CURRENT_PROFILE" ]; then
            switch_profile "$profile" "false"
            success "Automatisch zu Profil '$profile' für Verzeichnis '$current_dir' gewechselt."
        else
            if [ "$DEBUG" = true ]; then
                info "Profil '$profile' ist bereits aktiv."
            fi
        fi
        return 0
    else
        if [ "$DEBUG" = true ]; then
            warning "Kein passendes Profil für Verzeichnis '$current_dir' gefunden."
        fi
        return 1
    fi
}

# Erweiterte Profil-Liste
function list_profiles() {
    local profiles=$(load_profiles)

    # Prüfe ob Profile existieren
    local profile_count=$(echo "$profiles" | jq 'keys | length')
    if [ -z "$profile_count" ] || [ "$profile_count" -eq 0 ]; then
        warning "Keine Profile verfügbar."
        echo ""
        echo -e "${CYAN}Erstellen Sie ein neues Profil mit:${NC}"
        echo -e "  git-profile create "Name" "email@example.com" "github-user" "/path/to/project""
        return
    fi

    info "Verfügbare Profile ($profile_count):"
    echo ""

    for profile in $(echo "$profiles" | jq -r 'keys[]'); do
        echo -e "${GREEN}╔══ $profile ══════════════════════════════════════════════╗${NC}"

        # Werte mit Standardwerten
        local name=$(echo "$profiles" | jq -r --arg p "$profile" '.[$p]["user.name"] // "Nicht angegeben"')
        local email=$(echo "$profiles" | jq -r --arg p "$profile" '.[$p]["user.email"] // "Nicht angegeben"')
        local github=$(echo "$profiles" | jq -r --arg p "$profile" '.[$p]["github.user"] // "Nicht angegeben"')
        local created=$(echo "$profiles" | jq -r --arg p "$profile" '.[$p]["created"] // "Unbekannt"')

        echo -e "${GREEN}║${NC} ${CYAN}Name:${NC} $name"
        echo -e "${GREEN}║${NC} ${CYAN}E-Mail:${NC} $email"
        echo -e "${GREEN}║${NC} ${CYAN}GitHub-Benutzer:${NC} $github"
        echo -e "${GREEN}║${NC} ${CYAN}Erstellt am:${NC} $created"

        # SSH-Key anzeigen
        local ssh_key=$(echo "$profiles" | jq -r --arg p "$profile" '.[$p]["ssh.key"] // ""')
        if [ -n "$ssh_key" ] && [ "$ssh_key" != "null" ]; then
            if [ -f "$ssh_key" ]; then
                echo -e "${GREEN}║${NC} ${CYAN}SSH-Key:${NC} $ssh_key ✓"
            else
                echo -e "${GREEN}║${NC} ${CYAN}SSH-Key:${NC} $ssh_key ${RED}(nicht gefunden)${NC}"
            fi
        else
            echo -e "${GREEN}║${NC} ${CYAN}SSH-Key:${NC} ${YELLOW}Nicht konfiguriert${NC}"
        fi

        echo -e "${GREEN}║${NC} ${CYAN}Verzeichnisse:${NC}"

        # Verzeichnisse anzeigen
        if echo "$profiles" | jq -e --arg p "$profile" '.[$p] | has("directories")' > /dev/null; then
            if echo "$profiles" | jq -e --arg p "$profile" '.[$p].directories | type == "array"' > /dev/null; then
                local dir_count=$(echo "$profiles" | jq --arg p "$profile" '.[$p].directories | length')
                if [ "$dir_count" -gt 0 ]; then
                    for dir in $(echo "$profiles" | jq -r --arg p "$profile" '.[$p].directories[]'); do
                        if [ -n "$dir" ] && [ "$dir" != "null" ]; then
                            if [ -d "$dir" ]; then
                                echo -e "${GREEN}║${NC}   • $dir ✓"
                            else
                                echo -e "${GREEN}║${NC}   • $dir ${RED}(nicht gefunden)${NC}"
                            fi
                        fi
                    done
                else
                    echo -e "${GREEN}║${NC}   ${YELLOW}Keine Verzeichnisse definiert${NC}"
                fi
            else
                echo -e "${GREEN}║${NC}   ${YELLOW}Keine Verzeichnisse definiert${NC}"
            fi
        else
            echo -e "${GREEN}║${NC}   ${YELLOW}Keine Verzeichnisse definiert${NC}"
        fi

        echo -e "${GREEN}╚══════════════════════════════════════════════════════════╝${NC}"
        echo ""
    done

    # Aktives Profil anzeigen
    if [ -n "$CURRENT_PROFILE" ]; then
        echo -e "${YELLOW}Aktuelles Profil: $CURRENT_PROFILE${NC}"
    fi
}

# Profil löschen
function delete_profile() {
    local name="$1"

    if [ -z "$name" ]; then
        error "Profilname ist erforderlich."
        return 1
    fi

    local profiles=$(load_profiles)

    # Prüfe ob Profil existiert
    if ! echo "$profiles" | jq -e --arg name "$name" '.[$name]' > /dev/null; then
        error "Profil '$name' wurde nicht gefunden."
        return 1
    fi

    # Sicherheitsabfrage
    echo -e "${RED}WARNUNG: Das Profil '$name' wird permanent gelöscht!${NC}"
    read -p "Sind Sie sicher? Geben Sie 'DELETE' ein zum Bestätigen: " confirm

    if [ "$confirm" != "DELETE" ]; then
        info "Löschvorgang abgebrochen."
        return 0
    fi

    # SSH-Key löschen?
    local ssh_key=$(echo "$profiles" | jq -r --arg name "$name" '.[$name]["ssh.key"] // ""')
    if [ -n "$ssh_key" ] && [ "$ssh_key" != "null" ] && [ -f "$ssh_key" ]; then
        read -p "Soll der zugehörige SSH-Key ($ssh_key) ebenfalls gelöscht werden? (j/n): " delete_key
        if [[ "$delete_key" =~ ^[JjYy]$ ]]; then
            rm -f "$ssh_key" "${ssh_key}.pub"
            success "SSH-Key gelöscht: $ssh_key"
        fi
    fi

    # Profil aus Konfiguration entfernen
    local updated_profiles=$(echo "$profiles" | jq --arg name "$name" 'del(.[$name])')

    if save_profiles "$updated_profiles"; then
        success "Profil '$name' wurde gelöscht."
        log_action "Profil gelöscht: $name"
        return 0
    else
        error "Fehler beim Löschen des Profils."
        return 1
    fi
}

# Konfiguration anzeigen
function show_config() {
    info "Git Profile Manager Konfiguration:"
    echo ""
    echo -e "${CYAN}Konfigurationsdatei:${NC} $CONFIG_FILE"
    echo -e "${CYAN}Log-Datei:${NC} $LOG_FILE"
    echo -e "${CYAN}Version:${NC} $VERSION"
    echo -e "${CYAN}Debug-Modus:${NC} $DEBUG"
    echo ""

    if [ -f "$CONFIG_FILE" ]; then
        echo -e "${CYAN}Konfigurationsdatei-Inhalt:${NC}"
        echo "----------------------------------------"
        cat "$CONFIG_FILE" | jq '.' 2>/dev/null || cat "$CONFIG_FILE"
        echo "----------------------------------------"
    else
        warning "Konfigurationsdatei nicht gefunden."
    fi
}

# Self-Installation
function setup_self_installation() {
    show_banner
    info "Starte Selbst-Installation des Git Profile Managers..."

    # 1. Skript nach /usr/local/bin/git-profile kopieren
    local script_path=$(realpath "$0")
    local target_path="/usr/local/bin/git-profile"

    if [ "$script_path" != "$target_path" ]; then
        info "Kopiere Skript nach $target_path..."
        if sudo cp "$script_path" "$target_path"; then
            sudo chmod +x "$target_path"
            success "Skript wurde nach $target_path kopiert und ausführbar gemacht."
        else
            error "Fehler beim Kopieren des Skripts."
            return 1
        fi
    else
        success "Skript ist bereits im Zielpfad installiert."
    fi

    # .bashrc Integration prüfen und hinzufügen
    check_bashrc_integration

    success "Installation abgeschlossen! Git Profile Manager ist jetzt bereit zur Verwendung."
    echo ""
    echo -e "${CYAN}Erste Schritte:${NC}"
    echo "1. Erstellen Sie ein Profil: git-profile create "Name" "email@example.com" "github-user""
    echo "2. Fügen Sie Verzeichnisse hinzu: git-profile add-dir "Name" "/path/to/project""
    echo "3. Listen Sie Profile auf: git-profile list"
    echo ""
}

# .bashrc Integration prüfen und einfügen
function check_bashrc_integration() {
    local bashrc_file="$HOME/.bashrc"
    local integration_marker="# Git Profile Manager Auto-Switch"

    # Prüfe ob die Integration bereits in .bashrc ist
    if grep -q "$integration_marker" "$bashrc_file" 2>/dev/null; then
        success "Git Profile Manager Integration ist bereits in Ihrer .bashrc eingerichtet."
    else
        warning "Git Profile Manager Integration ist noch nicht in Ihrer .bashrc eingerichtet."

        while true; do
            read -p "Möchten Sie automatisches Profil-Wechseln zu Ihrer .bashrc hinzufügen? (j/n): " add_integration
            case $add_integration in
                [JjYy]*)
                    # Integration zu .bashrc hinzufügen
                    cat >> "$bashrc_file" << 'EOL'

# Git Profile Manager Auto-Switch
# Automatisches Wechseln der Git-Profile basierend auf dem aktuellen Verzeichnis
_git_profile_cd() {
    builtin cd "$@" || return $?
    if git rev-parse --git-dir > /dev/null 2>&1; then
        if command -v git-profile > /dev/null 2>&1; then
            git-profile auto > /dev/null 2>&1
        fi
    fi
}

# cd Funktion überschreiben für automatisches Profil-Wechseln
alias cd='_git_profile_cd'

# Initial bei Shell-Start ausführen
if git rev-parse --git-dir > /dev/null 2>&1; then
    if command -v git-profile > /dev/null 2>&1; then
        git-profile auto > /dev/null 2>&1
    fi
fi
EOL
                    success "Git Profile Manager Integration wurde zu Ihrer .bashrc hinzugefügt."

                    # Automatisch .bashrc neu laden
                    info ".bashrc wird neu geladen..."
                    if source "$bashrc_file" 2>/dev/null; then
                        success ".bashrc wurde neu geladen."
                    else
                        warning "Konnte .bashrc nicht automatisch neu laden. Führen Sie 'source ~/.bashrc' aus."
                    fi
                    break
                    ;;
                [Nn]*)
                    info "Integration wurde nicht hinzugefügt. Sie können manuell 'git-profile auto' ausführen."
                    break
                    ;;
                *)
                    warning "Bitte antworten Sie mit 'j' für ja oder 'n' für nein."
                    ;;
            esac
        done
    fi
}

# Backup erstellen
function create_backup() {
    local backup_file="$HOME/.git_profiles_backup_$(date +%Y%m%d_%H%M%S).json"

    if [ -f "$CONFIG_FILE" ]; then
        if cp "$CONFIG_FILE" "$backup_file"; then
            success "Backup erstellt: $backup_file"
            return 0
        else
            error "Fehler beim Erstellen des Backups."
            return 1
        fi
    else
        warning "Keine Konfigurationsdatei zum Sichern gefunden."
        return 1
    fi
}

# Backup wiederherstellen
function restore_backup() {
    local backup_file="$1"

    if [ -z "$backup_file" ]; then
        echo -e "${CYAN}Verfügbare Backup-Dateien:${NC}"
        ls -la "$HOME"/.git_profiles_backup_*.json 2>/dev/null || {
            warning "Keine Backup-Dateien gefunden."
            return 1
        }
        read -p "Geben Sie den Pfad zur Backup-Datei ein: " backup_file
    fi

    if [ ! -f "$backup_file" ]; then
        error "Backup-Datei '$backup_file' nicht gefunden."
        return 1
    fi

    # Validiere JSON
    if ! jq '.' "$backup_file" > /dev/null 2>&1; then
        error "Ungültige JSON-Datei: $backup_file"
        return 1
    fi

    # Aktuelles Backup erstellen
    create_backup

    # Backup wiederherstellen
    if cp "$backup_file" "$CONFIG_FILE"; then
        success "Backup wiederhergestellt: $backup_file"
        return 0
    else
        error "Fehler beim Wiederherstellen des Backups."
        return 1
    fi
}

# Status anzeigen
function show_status() {
    info "Git Profile Manager Status:"
    echo ""

    # Aktuelles Profil
    if [ -n "$CURRENT_PROFILE" ]; then
        echo -e "${CYAN}Aktuelles Profil:${NC} ${GREEN}$CURRENT_PROFILE${NC}"
    else
        echo -e "${CYAN}Aktuelles Profil:${NC} ${YELLOW}Keines aktiv${NC}"
    fi

    # Git-Konfiguration
    echo -e "${CYAN}Aktuelle Git-Konfiguration:${NC}"
    if git config user.name > /dev/null 2>&1; then
        echo -e "  Name: $(git config user.name)"
        echo -e "  E-Mail: $(git config user.email)"
        echo -e "  GitHub-Benutzer: $(git config github.user 2>/dev/null || echo 'Nicht gesetzt')"
        echo -e "  SSH-Command: $(git config core.sshCommand 2>/dev/null || echo 'Standard')"
    else
        echo -e "  ${YELLOW}Keine Git-Konfiguration gefunden${NC}"
    fi

    # Repository-Info
    if git rev-parse --git-dir > /dev/null 2>&1; then
        echo -e "${CYAN}Git-Repository:${NC} ${GREEN}✓${NC}"
        echo -e "  Pfad: $(git rev-parse --show-toplevel)"
        echo -e "  Branch: $(git branch --show-current 2>/dev/null || echo 'Unbekannt')"
    else
        echo -e "${CYAN}Git-Repository:${NC} ${YELLOW}Nicht in einem Git-Repository${NC}"
    fi

    # Profile-Statistiken
    local profiles=$(load_profiles)
    local profile_count=$(echo "$profiles" | jq 'keys | length' 2>/dev/null || echo "0")
    echo -e "${CYAN}Verfügbare Profile:${NC} $profile_count"
}

# Hilfe anzeigen
function show_help() {
    show_banner

    echo -e "${CYAN}VERWENDUNG:${NC}"
    echo -e "  git-profile ${GREEN}<BEFEHL>${NC} [OPTIONEN]"
    echo ""

    echo -e "${CYAN}BEFEHLE:${NC}"
    echo ""
    echo -e "  ${GREEN}create${NC} <name> <email> <github-user> [verzeichnis]"
    echo -e "    Erstellt ein neues Profil mit optionalem Verzeichnis"
    echo -e "    Beispiel: git-profile create "Work" "max@firma.com" "MaxFirma" "/pfad/zu/projekten/""
    echo ""
    echo -e "  ${GREEN}add-dir${NC} <name> <verzeichnis>"
    echo -e "    Fügt ein Verzeichnis zu einem bestehenden Profil hinzu"
    echo -e "    Beispiel: git-profile add-dir "Work" "/pfad/zu/mehr/projekten/""
    echo ""
    echo -e "  ${GREEN}switch${NC} <name>"
    echo -e "    Wechselt zu einem bestimmten Profil"
    echo -e "    Beispiel: git-profile switch "Work""
    echo ""
    echo -e "  ${GREEN}auto${NC} [debug]"
    echo -e "    Wechselt automatisch basierend auf dem aktuellen Verzeichnis"
    echo -e "    Mit 'debug' werden zusätzliche Informationen angezeigt"
    echo -e "    Beispiel: git-profile auto debug"
    echo ""
    echo -e "  ${GREEN}list${NC}"
    echo -e "    Zeigt alle verfügbaren Profile an"
    echo ""
    echo -e "  ${GREEN}delete${NC} <name>"
    echo -e "    Löscht ein Profil permanent"
    echo -e "    Beispiel: git-profile delete "Work""
    echo ""
    echo -e "  ${GREEN}status${NC}"
    echo -e "    Zeigt den aktuellen Status und die Git-Konfiguration an"
    echo ""
    echo -e "  ${GREEN}config${NC}"
    echo -e "    Zeigt die aktuelle Konfiguration an"
    echo ""
    echo -e "  ${GREEN}backup${NC}"
    echo -e "    Erstellt ein Backup der aktuellen Konfiguration"
    echo ""
    echo -e "  ${GREEN}restore${NC} [backup-datei]"
    echo -e "    Stellt ein Backup wieder her"
    echo ""
    echo -e "  ${GREEN}install${NC}"
    echo -e "    Installiert das Skript nach /usr/local/bin und richtet .bashrc ein"
    echo ""
    echo -e "  ${GREEN}version${NC}"
    echo -e "    Zeigt die Version an"
    echo ""
    echo -e "  ${GREEN}help${NC}"
    echo -e "    Zeigt diese Hilfe an"
    echo ""

    echo -e "${CYAN}KONFIGURATIONSDATEIEN:${NC}"
    echo -e "  Profile: ${YELLOW}$CONFIG_FILE${NC}"
    echo -e "  Logs: ${YELLOW}$LOG_FILE${NC}"
    echo ""

    echo -e "${CYAN}TIPPS:${NC}"
    echo -e "  • Verwenden Sie 'git-profile install' für die Ersteinrichtung"
    echo -e "  • Profile wechseln automatisch beim Navigieren in zugewiesene Verzeichnisse"
    echo -e "  • SSH-Keys werden automatisch verwaltet und zu GitHub/GitLab hinzugefügt"
    echo -e "  • Verwenden Sie 'git-profile auto debug' zur Fehlerbehebung"
    echo ""
}

# Version anzeigen
function show_version() {
    echo -e "${CYAN}Git Profile Manager${NC} Version ${GREEN}$VERSION${NC}"
    echo ""
    echo "Entwickelt für WSL2 und Linux-Systeme"
    echo "Unterstützt automatisches Profil-Wechseln und SSH-Key-Verwaltung"
}

# Hauptfunktion
function main() {
    # Abhängigkeiten prüfen
    check_dependencies

    # Konfiguration initialisieren
    initialize_config

    # Befehl verarbeiten
    case "${1:-help}" in
        create)
            if [ $# -lt 4 ]; then
                error "Zu wenige Argumente."
                echo -e "${CYAN}Verwendung:${NC} $0 create <name> <email> <github-benutzer> [verzeichnis]"
                exit 1
            fi
            create_profile "$2" "$3" "$4" "${5:-}"
            ;;
        add-dir)
            if [ $# -ne 3 ]; then
                error "Falsche Anzahl an Argumenten."
                echo -e "${CYAN}Verwendung:${NC} $0 add-dir <name> <verzeichnis>"
                exit 1
            fi
            add_directory "$2" "$3"
            ;;
        switch)
            if [ $# -ne 2 ]; then
                error "Falsche Anzahl an Argumenten."
                echo -e "${CYAN}Verwendung:${NC} $0 switch <name>"
                exit 1
            fi
            switch_profile "$2"
            ;;
        auto)
            # Debug-Modus für den auto-Befehl aktivieren
            if [ "$2" = "debug" ]; then
                DEBUG=true
                info "Debug-Modus aktiviert"
            fi
            auto_switch_profile
            ;;
        list)
            list_profiles
            ;;
        delete)
            if [ $# -ne 2 ]; then
                error "Falsche Anzahl an Argumenten."
                echo -e "${CYAN}Verwendung:${NC} $0 delete <name>"
                exit 1
            fi
            delete_profile "$2"
            ;;
        status)
            show_status
            ;;
        config)
            show_config
            ;;
        backup)
            create_backup
            ;;
        restore)
            restore_backup "$2"
            ;;
        install)
            setup_self_installation
            ;;
        version)
            show_version
            ;;
        help|*)
            show_help
            ;;
    esac
}

# Skript ausführen
main "$@"
exit $?
